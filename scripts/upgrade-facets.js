const hre = require("hardhat");
const ethers = hre.ethers;
const network = hre.network.name;
const { getFacets } = require("./config/facet-upgrade");
const environments = require("../environments");
const confirmations = network == "hardhat" ? 1 : environments.confirmations;
const tipMultiplier = ethers.BigNumber.from(environments.tipMultiplier);
const tipSuggestion = "1500000000"; // ethers.js always returns this constant, it does not vary per block
const maxPriorityFeePerGas = ethers.BigNumber.from(tipSuggestion).mul(tipMultiplier);
const { deployProtocolHandlerFacets } = require("./util/deploy-protocol-handler-facets.js");
const { FacetCutAction, getSelectors, removeSelectors } = require("./util/diamond-utils.js");
const { deploymentComplete, getFees, readContracts, writeContracts } = require("./util/utils.js");
const { getInterfaceIds, interfaceImplementers } = require("./config/supported-interfaces.js");
const Role = require("./domain/Role");
const packageFile = require("../package.json");
const readline = require("readline");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

/**
 * Upgrades or removes existing facets, or adds new facets.
 *
 * Prerequisite:
 * - Admin must have UPGRADER role. Use `manage-roles.js` to grant it.
 *
 * Process:
 *  1.  Edit scripts/config/facet-upgrade.js.
 *  1a. Provide a list of facets that needs to be upgraded (field "addOrUpgrade") or removed completely (field "remove")
 *  1b. Optionally you can specify which selectors should be ignored (field "skip"). You don't have to specify "initialize()" since it's ignored by default
 *  2. Update protocol version in package.json. If not, script will prompt you to confirm that version remains unchanged.
 *  2. Run the appropriate npm script in package.json to upgrade facets for a given network
 *  3. Save changes to the repo as a record of what was upgraded
 */
async function main(env, facetConfig) {
  // Bail now if hardhat network, unless the upgrade is tested
  if (network === "hardhat" && env !== "upgrade-test") process.exit();

  const chainId = (await ethers.provider.getNetwork()).chainId;
  const contractsFile = readContracts(chainId, network, env);
  let contracts = contractsFile.contracts;
  const interfaceIds = await getInterfaceIds();
  const interfaceIdFromFacetName = (facetName) => interfaceIds[interfaceImplementers[facetName]];

  const divider = "-".repeat(80);
  console.log(`${divider}\nBoson Protocol Contract Suite Upgrader\n${divider}`);
  console.log(`⛓  Network: ${network}\n📅 ${new Date()}`);

  const { version } = packageFile;
  // Check that package.json version was updated
  if (version == contractsFile.protocolVersion && env !== "upgrade-test") {
    const answer = await getUserResponse("Protocol version has not been updated. Proceed anyway? (y/n) ", [
      "y",
      "yes",
      "n",
      "no",
    ]);
    switch (answer.toLowerCase()) {
      case "y":
      case "yes":
        break;
      case "n":
      case "no":
      default:
        process.exit(1);
    }
  }

  // If hardhat, get an address generated by the mnemonic
  const adminAddress =
    network === "hardhat" ? (await ethers.getSigners())[0].address : environments[network].adminAddress;

  // If admin address is unspecified, exit the process
  if (adminAddress == ethers.constants.AddressZero || !adminAddress) {
    console.log("Admin address must not be zero address");
    process.exit(1);
  }

  // Get list of accounts managed by node
  const nodeAccountList = (await ethers.provider.listAccounts()).map((address) => address.toLowerCase());

  if (nodeAccountList.includes(adminAddress.toLowerCase())) {
    console.log("🔱 Admin account: ", adminAddress);
  } else {
    console.log("🔱 Admin account not found");
    process.exit(1);
  }
  console.log(divider);

  // Get signer for admin address
  const adminSigner = await ethers.getSigner(adminAddress);

  // Get addresses of currently deployed contracts
  const protocolAddress = contracts.find((c) => c.name === "ProtocolDiamond").address;
  const accessControllerAddress = contracts.find((c) => c.name === "AccessController").address;

  if (!protocolAddress) {
    return addressNotFound("ProtocolDiamond");
  }

  if (!accessControllerAddress) {
    return addressNotFound("AccessController");
  }

  // Get AccessController abstraction
  const accessController = await ethers.getContractAt("AccessController", accessControllerAddress);

  // Check that caller has upgrader role.
  const hasRole = await accessController.hasRole(Role.UPGRADER, adminAddress);
  if (!hasRole) {
    console.log("Admin address does not have UPGRADER role");
    process.exit(1);
  }

  // Get facets to upgrade
  let facets;
  if (facetConfig) {
    // facetConfig was passed in as a JSON object
    facets = JSON.parse(facetConfig);
  } else {
    // Get values from default config file
    facets = await getFacets();
  }

  // Deploy new facets
  const deployedFacets = await deployProtocolHandlerFacets(
    protocolAddress,
    facets.addOrUpgrade,
    maxPriorityFeePerGas,
    false
  );

  // Cast Diamond to DiamondCutFacet, DiamondLoupeFacet and IERC165Extended
  const diamondCutFacet = await ethers.getContractAt("DiamondCutFacet", protocolAddress);
  const diamondLoupe = await ethers.getContractAt("DiamondLoupeFacet", protocolAddress);
  const erc165Extended = await ethers.getContractAt("IERC165Extended", protocolAddress);

  const facetCut = [],
    facetCutRemove = [];
  const interfacesToRemove = [],
    interfacesToAdd = [];

  // Manage new or upgraded facets
  for (const newFacet of deployedFacets) {
    console.log(`\n📋 Facet: ${newFacet.name}`);

    // Get currently registered selectors
    const oldFacet = contracts.find((i) => i.name === newFacet.name);
    let registeredSelectors;
    if (oldFacet) {
      // Facet already exists and is only upgraded
      registeredSelectors = await diamondLoupe.facetFunctionSelectors(oldFacet.address);
    } else {
      // Facet is new
      registeredSelectors = [];
    }

    // Remove old entry from contracts
    contracts = contracts.filter((i) => i.name !== newFacet.name);

    const newFacetInterfaceId = interfaceIdFromFacetName(newFacet.name);
    deploymentComplete(newFacet.name, newFacet.contract.address, [], newFacetInterfaceId, contracts);

    // Get new selectors from compiled contract
    const selectors = getSelectors(newFacet.contract, true);
    let newSelectors;

    // Only ProtocolInitializationFacet should call initializer directly from diamondCut
    // if (newFacet.name == "ProtocolInitializationFacet") {
    //   newSelectors = selectors.selectors.remove([callData.slice(0, 10)]);
    // } else {
    newSelectors = selectors.selectors;
    // }

    // Determine actions to be made
    let selectorsToReplace = registeredSelectors.filter((value) => newSelectors.includes(value)); // intersection of old and new selectors
    let selectorsToRemove = registeredSelectors.filter((value) => !selectorsToReplace.includes(value)); // unique old selectors
    let selectorsToAdd = newSelectors.filter((value) => !selectorsToReplace.includes(value)); // unique new selectors

    // Skip selectors if set in config
    let selectorsToSkip = facets.skipSelectors[newFacet.name] ? facets.skipSelectors[newFacet.name] : [];
    selectorsToReplace = removeSelectors(selectorsToReplace, selectorsToSkip);
    selectorsToRemove = removeSelectors(selectorsToRemove, selectorsToSkip);
    selectorsToAdd = removeSelectors(selectorsToAdd, selectorsToSkip);

    // Check if selectors that are being added are not registered yet on some other facet
    // If collision is found, user must choose to either (s)kip it or (r)eplace it.
    for (const selectorToAdd of selectorsToAdd) {
      const existingFacetAddress = await diamondLoupe.facetAddress(selectorToAdd);
      if (existingFacetAddress != ethers.constants.AddressZero) {
        // Selector exist on some other facet
        const selectorName = selectors.signatureToNameMapping[selectorToAdd];
        const prompt = `Selector ${selectorName} is already registered on facet ${existingFacetAddress}. Do you want to (r)eplace or (s)kip it? `;
        const answer = await getUserResponse(prompt, ["r", "s"]);
        if (answer == "r") {
          // User chose to replace
          selectorsToReplace.push(selectorToAdd);
        } else {
          // User chose to skip
          selectorsToSkip.push(selectorName);
        }
        // In any case, remove it from selectorsToAdd
        selectorsToAdd = removeSelectors(selectorsToAdd, [selectorName]);
      }
    }
    //
    // Logs
    console.log(`💎 Removing selectors:\n\t${selectorsToRemove.join("\n\t")}`);
    console.log(
      `💎 Replacing selectors:\n\t${selectorsToReplace
        .map((selector) => `${selector}: ${selectors.signatureToNameMapping[selector]}`)
        .join("\n\t")}`
    );
    console.log(
      `💎 Adding selectors:\n\t${selectorsToAdd
        .map((selector) => `${selector}: ${selectors.signatureToNameMapping[selector]}`)
        .join("\n\t")}`
    );
    console.log(`❌ Skipping selectors:\n\t${selectorsToSkip.join("\n\t")}`);

    const newFacetAddress = newFacet.contract.address;
    if (selectorsToAdd.length > 0) {
      facetCut.push([newFacetAddress, FacetCutAction.Add, selectorsToAdd]);
    }
    if (selectorsToReplace.length > 0) {
      facetCut.push([newFacetAddress, FacetCutAction.Replace, selectorsToReplace]);
    }
    if (selectorsToRemove.length > 0) {
      facetCutRemove.push([ethers.constants.AddressZero, FacetCutAction.Remove, selectorsToRemove]);
    }

    if (oldFacet && (selectorsToAdd.length > 0 || selectorsToRemove.length > 0)) {
      if (!oldFacet.interfaceId) {
        console.log(
          `Could not find interface id for old facet ${oldFacet.name}.\nYou might need to remove its interfaceId from "supportsInterface" manually.`
        );
      } else {
        if (oldFacet.interfaceId == newFacetInterfaceId) {
          // This can happen if interface is shared accross facets and interface was updated already
          continue;
        }

        interfacesToRemove.push(oldFacet.interfaceId);

        // Check if interface was shared across other facets and update contracts info
        contracts = contracts.map((entry) => {
          if (entry.interfaceId == oldFacet.interfaceId) {
            entry.interfaceId = newFacetInterfaceId;
          }
          return entry;
        });
      }

      const support = await erc165.supportsInterface(newFacetInterfaceId);
      if (!support) {
        interfacesToAdd.push(newFacetInterfaceId);
      }
    }
  }

  // Manage facets that are being completely removed
  for (const facetToRemove of facets.remove) {
    // Get currently registered selectors
    const oldFacet = contracts.find((i) => i.name === facetToRemove);

    let registeredSelectors;
    if (oldFacet) {
      // Facet already exists and is only upgraded
      registeredSelectors = await diamondLoupe.facetFunctionSelectors(oldFacet.address);
    } else {
      // Facet does not exist, skip next steps
      continue;
    }
    console.log(`\n📋💀 Facet removal: ${facetToRemove}`);

    // Remove old entry from contracts
    contracts = contracts.filter((i) => i.name !== facetToRemove);

    // All selectors must be removed
    let selectorsToRemove = registeredSelectors; // all selectors must be removed

    // Removing the selectors
    facetCutRemove.push([ethers.constants.AddressZero, FacetCutAction.Remove, selectorsToRemove]);

    // Logs
    console.log(`💎 Removing selectors:\n\t${selectorsToRemove.join("\n\t")}`);

    if (oldFacet) {
      // Remove support for old interface
      if (!oldFacet.interfaceId) {
        console.log(
          `Could not find interface id for old facet ${oldFacet.name}.\nYou might need to remove its interfaceId from "supportsInterface" manually.`
        );
      } else {
        // Remove from smart contract
        interfacesToRemove.push(oldFacet.interfaceId);
        //
        // Check if interface was shared across other facets and update contracts info
        contracts = contracts.map((entry) => {
          if (entry.interfaceId == oldFacet.interfaceId) {
            entry.interfaceId = "";
          }
          return entry;
        });
      }
    }
  }

  // Diamond cut - add and replace
  const protocolInitializationFacet = deployedFacets.find(
    (f) => f.name == "ProtocolInitializationFacet"
  ).contract;

  const calldataList = [];
  const addresses = [];

  for (const facet of facets.facetsToInit) {
    const contract = deployedFacets.find((f) => f.name == facet).contract;

    addresses.push(contract.address);
    calldataList.push(contract.interface.encodeFunctionData("initialize", facets.initArgs[facet]));
  }

  const calldataProtocolInitialization = protocolInitializationFacet.interface.encodeFunctionData("initialize", [
    // Version
    ethers.utils.formatBytes32String(version),
    // Facets to call initializer
    addresses,
    // Calldata to facets initializer
    calldataList,
    // Is upgrade
    true,
  ]);

  let transactionResponse;

  // Adding and replacing are done in one diamond cut
  console.log("\n🔪 Diamond cut ++++++++++++");
  console.log(calldataProtocolInitialization);
  transactionResponse = await diamondCutFacet
    .connect(adminSigner)
    .diamondCut(
      facetCut,
      protocolInitializationFacet.address,
      calldataProtocolInitialization,
      await getFees(maxPriorityFeePerGas)
    );

  const response = await transactionResponse.wait(confirmations);
  console.log("response", response);

  // Removing is done in a separate diamond cut
  if (facetCutRemove.length > 0) {
    transactionResponse = await diamondCutFacet
      .connect(adminSigner)
      .diamondCut(facetCutRemove, ethers.constants.AddressZero, "0x", await getFees(maxPriorityFeePerGas));
    await transactionResponse.wait(confirmations);
  }

  // If something was added or removed, support interface for old interface is not valid anymore
  const erc165 = await ethers.getContractAt("IERC165", protocolAddress);

  // Remove interfaces
  for (const interfaceId of interfacesToRemove) {
    await erc165Extended
      .connect(adminSigner)
      .removeSupportedInterface(interfaceId, await getFees(maxPriorityFeePerGas));

    console.log(`Removed supported interface ${interfaceId} from supported interfaces.`);
  }

  // Register new interfaces
  for (const interfaceId of interfacesToAdd) {
    await erc165Extended.connect(adminSigner).addSupportedInterface(interfaceId, await getFees(maxPriorityFeePerGas));
    console.log(`Added new interfaceId ${interfaceId} to supported interfaces.`);
  }

  // @TODO - not working
  const newVersion = await protocolInitializationFacet.getVersion();
  console.log(`New version: ${newVersion}`);
  console.log(`\n📋 New version: ${ethers.utils.parseBytes32String(newVersion)}`);

  const contractsPath = await writeContracts(contracts, env);
  console.log(divider);
  console.log(`✅ Contracts written to ${contractsPath}`);
  console.log(divider);

  console.log(`\n📋 Diamond upgraded.`);
  console.log("\n");
}

const addressNotFound = (address) => {
  console.log(`${address} address not found for network ${network}`);
  process.exit(1);
};

async function getUserResponse(question, validResponses) {
  console.error(question);
  const answer = await new Promise((resolve) => {
    rl.question("", resolve);
  });
  if (validResponses.includes(answer)) {
    return answer;
  } else {
    console.error("Invalid response!");
    return await getUserResponse(question, validResponses);
  }
}

exports.upgradeFacets = main;
